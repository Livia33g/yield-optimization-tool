import matplotlib.pyplot as plt
import pdb
from tqdm import tqdm
import numpy as onp
import itertools
from copy import deepcopy
import pickle


import jax.numpy as jnp
import optax
from jax import jit, grad, vmap, value_and_grad, hessian, jacfwd, jacrev, random, lax
from jax_md import space

import potentials
from jax_transformations3d import jax_transformations3d as jts

from jax.config import config
config.update("jax_debug_nans", True)
config.update("jax_enable_x64", True)


# Load species
def load_species_combinations(filename):
    with open(filename, 'rb') as f:
        data = pickle.load(f)
    return data

data = load_species_combinations('AB_species_test.pkl')


# Define constants
V = 1.0
kT = 1.0
n = 2 # number of monomers
tot_num_structures = data['mon_pc_species'].shape[0] + data['dimer_pc_species'].shape[0] + data['trimer_pc_species'].shape[0]
vertex_species = 0
n_species = 5
a = 1 # distance of the center of the spheres from the BB COM
b = .3 # distance of the center of the patches from the BB COM
vertex_radius = a
patch_radius = 0.2*a


# Define helper functions
euler_scheme = "sxyz"
def convert_to_matrix(mi):
    """
    Convert a set x, y, z, alpha, beta, gamma into a jts transformation matrix
    """
    T = jts.translation_matrix(mi[:3])
    R = jts.euler_matrix(mi[3], mi[4], mi[5], axes=euler_scheme)
    return jnp.matmul(T,R)

def get_positions(q, ppos):
    Mat = []
    for i in range(len(ppos)):  
        qi = i * 6
        Mat.append(convert_to_matrix(q[qi:qi+6]))

    real_ppos = []
    for i, mat in enumerate(Mat):
        real_ppos.append(jts.matrix_apply(mat, ppos[i]))
    
    real_ppos = jnp.array(real_ppos)
    real_ppos = real_ppos.reshape(-1, 3)

    return real_ppos 

# Define shapes

separation = 2.0
noise = 1e-14

shape = onp.array([
    [-a, 0., b], # first patch
    [-a, b*onp.cos(onp.pi/6.), -b*onp.sin(onp.pi/6.)], # second patch
    [-a, -b*onp.cos(onp.pi/6.), -b*onp.sin(onp.pi/6.)], 
    [0., 0., a],
    [0., a*onp.cos(onp.pi/6.), -a*onp.sin(onp.pi/6.)], # second sphere
    [0., -a*onp.cos(onp.pi/6.), -a*onp.sin(onp.pi/6.)], # third sphere
    [a, 0., b], # first patch
    [a, b*onp.cos(onp.pi/6.), -b*onp.sin(onp.pi/6.)], # second patch
    [a, -b*onp.cos(onp.pi/6.), -b*onp.sin(onp.pi/6.)] # third patch
])
mon_shape = jnp.array([shape])
dimer_shape = jnp.array([shape, shape])
trimer_shape = jnp.array([shape, shape, shape])

mon_rb = jnp.array([0, 0, 0, 0, 0, 0], dtype=jnp.float64)

dimer_rb = jnp.array([-separation/2.0, noise, 0, 0, 0, 0,
                     separation/2.0, 0, 0, 0, 0, 0], dtype=jnp.float64)

trimer_rb = jnp.array([-separation, noise, 0, 0, 0, 0,   
                       0, 0, 0, 0, 0, 0,                
                       separation, noise, 0, 0, 0, 0],      
                      dtype=jnp.float64)


# Energy helper functions

small_value = 1e-12
morse_eps_table = onp.full((n_species, n_species), small_value)
default_strong_eps = 10.0
morse_eps_table[onp.array([2, 3]), onp.array([3, 2])] = default_strong_eps
morse_eps_table = jnp.array(morse_eps_table)


morse_narrow_alpha = 5.0
# morse_wide_alpha = 1.0
morse_alpha_table = onp.full((n_species, n_species), morse_narrow_alpha)
morse_alpha_table[onp.array([2, 3]), onp.array([3, 2])] = morse_narrow_alpha
morse_alpha_table = jnp.array(morse_alpha_table)

def pairwise_morse(ipos, jpos, i_species, j_species):
    morse_d0 = morse_eps_table[i_species, j_species]
    morse_alpha = morse_alpha_table[i_species, j_species]
  
    morse_r0 = 0.0                                   
    morse_rcut = 8.0 / morse_alpha + morse_r0
    dr = space.distance(ipos - jpos)
                     
    return potentials.morse_x(dr, rmin=morse_r0, rmax=morse_rcut, D0=morse_d0, 
                              alpha=morse_alpha, r0=morse_r0, ron=morse_rcut/2.0)


rep_A_table = onp.full((n_species, n_species), small_value)  
rep_A_table[vertex_species, vertex_species] = 500.0  
rep_A_table = jnp.array(rep_A_table)

rep_rmax_table = onp.full((n_species, n_species), 2*vertex_radius)  
rep_rmax_table = jnp.array(rep_rmax_table)

rep_strong_alpha = 2.5
rep_alpha_table = onp.full((n_species, n_species), rep_strong_alpha)
rep_alpha_table = jnp.array(rep_alpha_table)

def pairwise_repulsion(ipos, jpos, i_species, j_species):
    rep_rmax = rep_rmax_table[i_species, j_species]
    rep_a = rep_A_table[i_species, j_species]
    rep_alpha = rep_alpha_table[i_species, j_species]
    dr = space.distance(ipos - jpos)

    return potentials.repulsive(dr, rmin=0, rmax=rep_rmax,
                                A=rep_a, alpha=rep_alpha)

# Energy functions for different sizes

def dimer_energy(q, pos, species):
    """
    q: is the center of mass positions
    pos: body-frame positions of the rigid body
    species: the species of the unwrapped positions
    """
    
    positions = get_positions(q, pos) # 18 particles (9 per monomer)
    
    pos1 = positions[:9] # First monomer
    pos2 = positions[9:] # Last monomer
                 
    species1 = species[:3]  
    species2 = species[3:]
    species1 = onp.repeat(species1, 3) 
    species2 = onp.repeat(species2, 3)
    
    morse_func = vmap(vmap(pairwise_morse, in_axes=(None, 0, None, 0)), in_axes=(0, None, 0, None))
    tot_energy = jnp.sum(morse_func(pos1, pos2, species1, species2))

    inner_rep = vmap(pairwise_repulsion, in_axes=(None, 0, None, 0))
    rep_func = vmap(inner_rep, in_axes=(0, None, 0, None))
    tot_energy += jnp.sum(rep_func(pos1, pos2, species1, species2))               
    return tot_energy 


# TODO: make monomer and trimer energy functions


# Test calls to energy functions
pdb.set_trace()
dimer_energy(dimer_rb, dimer_shape, data['dimer_pc_species'][1])

# TODO: add example calls for monomer and trimer energy functions


# TODO: Precompute partition functions and save to file (or load from file)

# TODO: setup yield calculation/optimization

# TODO: do a single yield calculation with a fixed set of concentrations

# TODO: setup an optimization
